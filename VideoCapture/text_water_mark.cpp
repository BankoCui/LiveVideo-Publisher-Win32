#include "stdafx.h"
#include "text_water_mark.h"

#include <stdio.h>
#include <string.h>

/*
 * yuv420p添加水印_标准可读时间_逻辑实现：
 * 0-9这10个字符的16*16点阵定义，
 * 中线的16*16点阵定义，
 * 冒号的16*16点阵定义，
 * 空格的16*16点阵定义，
 *
 * 19个字符（字节）的时间串通过系统时间产生，每个字符从上面定义的13个字模中查找，然后构造19个连续地址的字模的点阵
 */


unsigned char sign_0[] = {
	0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xF0,0x1C,0x38,0x38,0x1C,0x38,0x1C,0x78,0x1E,
	0x78,0x1E,0x38,0x1C,0x38,0x1C,0x38,0x1C,0x1C,0x38,0x07,0xE0,0x00,0x00,0x00,0x00
};

unsigned char sign_1[] = {
	0x00,0x00,0x00,0x00,0x00,0x00,0x01,0xC0,0x0F,0xC0,0x01,0xC0,0x01,0xC0,0x01,0xC0,
	0x01,0xC0,0x01,0xC0,0x01,0xC0,0x01,0xC0,0x01,0xC0,0x1F,0xF8,0x00,0x00,0x00,0x00
};

unsigned char sign_2[] = {
	0x00,0x00,0x00,0x00,0x00,0x00,0x0F,0xF0,0x18,0x18,0x38,0x1C,0x38,0x1C,0x00,0x38,
	0x00,0x70,0x01,0xC0,0x07,0x00,0x0C,0x04,0x3F,0xFC,0x3F,0xFC,0x00,0x00,0x00,0x00
};

unsigned char sign_3[] = {
	0x00,0x00,0x00,0x00,0x00,0x00,0x0F,0xF0,0x38,0x38,0x38,0x18,0x00,0x38,0x03,0xF0,
	0x03,0xF0,0x00,0x18,0x00,0x1C,0x38,0x1C,0x38,0x18,0x1F,0xF0,0x00,0x00,0x00,0x00
};

unsigned char sign_4[] = {
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x30,0x00,0xF0,0x01,0xF0,0x02,0x70,0x0C,0x70,
	0x18,0x70,0x30,0x70,0x3F,0xFE,0x00,0x70,0x00,0x70,0x03,0xFE,0x00,0x00,0x00,0x00
};

unsigned char sign_5[] = {
	0x00,0x00,0x00,0x00,0x00,0x00,0x1F,0xFC,0x18,0x00,0x18,0x00,0x18,0xC0,0x1F,0xF8,
	0x18,0x1C,0x00,0x1C,0x10,0x1C,0x38,0x1C,0x38,0x18,0x0F,0xF0,0x00,0x00,0x00,0x00
};

unsigned char sign_6[] = {
	0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xF8,0x0C,0x38,0x18,0x10,0x38,0x00,0x3F,0xF8,
	0x7C,0x1C,0x78,0x0C,0x38,0x0E,0x38,0x0C,0x1C,0x18,0x0F,0xF0,0x00,0x00,0x00,0x00
};

unsigned char sign_7[] = {
	0x00,0x00,0x00,0x00,0x00,0x00,0x1F,0xFE,0x38,0x0C,0x30,0x10,0x00,0x30,0x00,0x60,
	0x00,0xC0,0x01,0x80,0x03,0x80,0x03,0x80,0x03,0x80,0x03,0x80,0x00,0x00,0x00,0x00
};

unsigned char sign_8[] = {
	0x00,0x00,0x00,0x00,0x00,0x00,0x0F,0xF0,0x38,0x1C,0x30,0x0C,0x3C,0x1C,0x1F,0xF0,
	0x0F,0xF0,0x38,0x78,0x70,0x1C,0x70,0x0C,0x38,0x18,0x0F,0xF0,0x00,0x00,0x00,0x00
};

unsigned char sign_9[] = {
	0x00,0x00,0x00,0x00,0x00,0x00,0x0F,0xF0,0x38,0x18,0x30,0x1C,0x70,0x1C,0x70,0x1C,
	0x38,0x3C,0x1F,0xDC,0x00,0x1C,0x18,0x38,0x3C,0x70,0x1F,0xE0,0x00,0x00,0x00,0x00
};

unsigned char sign_mid_line[] = {
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3F,0xFE,
	0x3F,0xFE,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
};

unsigned char sign_colon[] = {
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x80,0x03,0xC0,
	0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0xC0,0x03,0x80,0x00,0x00,0x00,0x00
};

unsigned char sign_space[] = {
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
};

void systemTimeTable(char* strTime, int time_len, unsigned char* text_table) {
  char* pTime = strTime;
  for (int i = 0; i < time_len & pTime != '\0'; i++, pTime++) {
    if (*pTime == '0') {
      memcpy(text_table + i*TEXT_WORD_SIZE, sign_0, sizeof(sign_0));
    } else if (*pTime == '1') {
      memcpy(text_table + i*TEXT_WORD_SIZE, sign_1, sizeof(sign_1));
    } else if (*pTime == '2') {
      memcpy(text_table + i*TEXT_WORD_SIZE, sign_2, sizeof(sign_2));
    } else if (*pTime == '3') {
      memcpy(text_table + i*TEXT_WORD_SIZE, sign_3, sizeof(sign_3));
    } else if (*pTime == '4') {
      memcpy(text_table + i*TEXT_WORD_SIZE, sign_4, sizeof(sign_4));
    } else if (*pTime == '5') {
      memcpy(text_table + i*TEXT_WORD_SIZE, sign_5, sizeof(sign_5));
    } else if (*pTime == '6') {
      memcpy(text_table + i*TEXT_WORD_SIZE, sign_6, sizeof(sign_6));
    } else if (*pTime == '7') {
      memcpy(text_table + i*TEXT_WORD_SIZE, sign_7, sizeof(sign_7));
    } else if (*pTime == '8') {
      memcpy(text_table + i*TEXT_WORD_SIZE, sign_8, sizeof(sign_8));
    } else if (*pTime == '9') {
      memcpy(text_table + i*TEXT_WORD_SIZE, sign_9, sizeof(sign_9));
    } else if (*pTime == '-') {
      memcpy(text_table + i*TEXT_WORD_SIZE, sign_mid_line, sizeof(sign_mid_line));
    } else if (*pTime == ':') {
      memcpy(text_table + i*TEXT_WORD_SIZE, sign_colon, sizeof(sign_colon));
    } else if (*pTime == ' ') {
      memcpy(text_table + i*TEXT_WORD_SIZE, sign_space, sizeof(sign_space));
    }
  }
}

/*
* Function:     draw_Font_Func
* Description:  实现在yuv420图片上面画字 
* Input:        char *ptr_frame             一帧视频的首地址
*               const unsigned char font[]  画的字模
*               int startx                  写字的起点坐标x
*               int starty                  写字的起点坐标y
*               int color                   字颜色的选择，具体颜色在程序代码
* Return:       这里会把传进来的一帧视频的地址返回，可以不调用  
*/
char *draw_Font_Func(char *ptr_frame, int width, int height,
	char* strTime,
	int startx, int starty,
	int color)
{

	assert( ptr_frame != NULL );

	// example: 2018-10-30 08:08:08
	int time_len = strlen(strTime);
	// time string table
	int text_table_size = TEXT_WORD_SIZE*time_len;
	unsigned char* text_table = new unsigned char[text_table_size];
	memset(text_table, 0, text_table_size);
	systemTimeTable(strTime, time_len, text_table);

	int tagY=0,tagU=0,tagV=0;
	char *offsetY=NULL,*offsetU=NULL,*offsetV=NULL;
	unsigned short p16, mask16; // for reading hzk16 dots

	/*yuv 地址的设置 */
	offsetY = ptr_frame;
	offsetU = offsetY + width * height;
	offsetV = offsetU + width * height/4;

	switch (color)
	{
	case 0:         // Yellow
		tagY = 226;tagU = 0;tagV = 149;
		break;
	case 1:         // Red
		tagY = 76;tagU = 85;tagV = 255;
		break;
	case 2:         // Green
		tagY = 150;tagU = 44;tagV = 21;
		break;
	case 3:         // Blue
		tagY = 29;tagU = 255;tagV = 107;
		break;
	case 4:         // Gray
		tagY = 128;tagU = 128;tagV = 128;
		break;
	case 5:         // White 该色值还需要重新计算
		tagY = 255;tagU = 0;tagV = 0;
	default:        // White White 该色值还需要重新计算
		tagY = 255;tagU = 255;tagV = 255;
	}  

	int x=0,y=0,i=0,j=0,k=0;
	for(i = 0; i < time_len; i++)
	{
#if 0
		for (j = 0, y = starty; j < 16 && y < height - 1; j++, y+=2)    // line dots per char
		{
			p16 = *(unsigned short *)(text_table + j*2 + i*32);/*取字模数据*/
			mask16 = 0x0080;  /* 二进制 1000 0000 */
			for (k = 0, x = startx +i*36; k < 16 && x < width - 1; k++, x+=2)   // dots in a line
			{
				if (p16 & mask16)
				{
					*(offsetY + y*width + x) = *(offsetY + y*width + x+1) = tagY;
					*(offsetY + (y+1)*width + x) = *(offsetY + (y+1)*width + x+1) = tagY;   
					*(offsetU + y * width/4 + x/2) =tagU;
					*(offsetV + y * width/4 + x/2) = tagV;
				}
				mask16 = mask16 >> 1;  /* 循环移位取数据 */
				if (mask16 == 0)
					mask16 = 0x8000;
			}
		}
#else
		for (j = 0, y = starty; j < 16 && y < height - 1; j++, y++) // line dots per char
		{
			p16 = *(unsigned short *)(text_table + j*2 + i*32);/*取字模数据*/
			mask16 = 0x0080;  /* 二进制 1000 0000 */
			for (k = 0, x = startx +i*16; k < 16 && x < width - 1; k++, x++)    // dots in a line
			{
				if (p16 & mask16)
				{
					*(offsetY + y*width + x) = tagY;
					if(y%2 == 0) //starty为奇数或者偶数与整体的位置有关，上或下会有削减。。但是此处的逻辑必须是y%2==0，不能是y%2!=0
					{
						*(offsetU + y * width/4 + x/2) = tagU;
						*(offsetV + y * width/4 + x/2) = tagV;
					}
					else
					{
						*(offsetU + (y-1) * width/4 + x/2) = tagU;
						*(offsetV + (y-1) * width/4 + x/2) = tagV;
					}					
				}
				mask16 = mask16 >> 1;  /* 循环移位取数据 */
				if (mask16 == 0)
					mask16 = 0x8000;
			}
		}
#endif
	}

	delete[] text_table;
	text_table = NULL;
	return (char *)ptr_frame;
}